# ğŸ“‹ é¢è¯•é—´åˆ—è¡¨åŠŸèƒ½å¼€å‘æ–‡æ¡£

## ğŸ¯ åŠŸèƒ½æ¦‚è¿°

å®ç°é¢è¯•é—´ç®¡ç†åŠŸèƒ½ï¼Œè®©æ¯ä¸ªç”¨æˆ·å¯ä»¥æŸ¥çœ‹å’Œç®¡ç†è‡ªå·±åˆ›å»ºçš„é¢è¯•é—´ï¼Œæ”¯æŒé‡æ–°è¿›å…¥è¿›è¡Œä¸­çš„é¢è¯•é—´ã€æŸ¥çœ‹å†å²è®°å½•ç­‰ã€‚

### æ ¸å¿ƒéœ€æ±‚
1. âœ… æ¯ä¸ªç”¨æˆ·åªèƒ½çœ‹åˆ°è‡ªå·±åˆ›å»ºçš„é¢è¯•é—´ï¼ˆæƒé™éš”ç¦»ï¼‰
2. âœ… åŒºåˆ†ã€Œè¿›è¡Œä¸­ã€å’Œã€Œå·²ç»“æŸã€çŠ¶æ€
3. âœ… æ”¯æŒé‡æ–°è¿›å…¥è¿›è¡Œä¸­çš„é¢è¯•é—´
4. âœ… æ”¯æŒæ‰‹åŠ¨ç»“æŸé¢è¯•é—´
5. âœ… æ˜¾ç¤ºé¢è¯•é—´è¯¦ç»†ä¿¡æ¯ï¼ˆå‚ä¸è€…ã€æ—¶é•¿ç­‰ï¼‰
6. âŒ æš‚ä¸å®ç°å½•åˆ¶åŠŸèƒ½ï¼ˆé¿å…æ€§èƒ½å½±å“å’Œé¢å¤–è´¹ç”¨ï¼‰

---

## ğŸ“Š æ•°æ®æ¨¡å‹è®¾è®¡

### Interview Room Entity

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/interview/models/interview-room.entity.ts`

```typescript
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

// å‚ä¸è€…å­æ–‡æ¡£
@Schema({ _id: false })
export class Participant {
  @Prop({ required: true })
  userId: string; // ZEGO ç”¨æˆ·IDï¼ˆguest_xxx æˆ– user_xxxï¼‰

  @Prop({ required: true })
  userName: string;

  @Prop({ required: true, enum: ['host', 'guest'] })
  role: 'host' | 'guest';

  @Prop()
  identity?: string; // è®¿å®¢èº«ä»½ï¼ˆæ±‚èŒè€…å¡«å†™çš„ï¼‰

  @Prop({ required: true })
  joinedAt: Date;

  @Prop()
  leftAt?: Date;
}

export const ParticipantSchema = SchemaFactory.createForClass(Participant);

// é¢è¯•é—´ä¸»å®ä½“
@Schema({ timestamps: true, collection: 'interview_rooms' })
export class InterviewRoom extends Document {
  @Prop({ required: true, unique: true, index: true })
  roomId: string; // æˆ¿é—´IDï¼ˆå”¯ä¸€ï¼‰

  @Prop({ required: true })
  roomName: string; // æˆ¿é—´åç§°

  @Prop({ type: Types.ObjectId, ref: 'User', required: true, index: true })
  hostUserId: Types.ObjectId; // ä¸»æŒäººç”¨æˆ·IDï¼ˆå…³è”Userè¡¨ï¼Œç”¨äºæƒé™æ§åˆ¶ï¼‰

  @Prop({ required: true })
  hostName: string; // ä¸»æŒäººå§“å

  @Prop({ required: true })
  hostZegoUserId: string; // ä¸»æŒäººZEGOç”¨æˆ·IDï¼ˆuser_xxxæ ¼å¼ï¼‰

  @Prop({ required: true, enum: ['active', 'ended'], default: 'active', index: true })
  status: 'active' | 'ended'; // çŠ¶æ€

  @Prop({ required: true })
  createdAt: Date; // åˆ›å»ºæ—¶é—´

  @Prop()
  endedAt?: Date; // ç»“æŸæ—¶é—´

  @Prop()
  duration?: number; // æŒç»­æ—¶é•¿ï¼ˆç§’ï¼‰

  @Prop({ type: [ParticipantSchema], default: [] })
  participants: Participant[]; // å‚ä¸è€…åˆ—è¡¨
}

export const InterviewRoomSchema = SchemaFactory.createForClass(InterviewRoom);

// åˆ›å»ºç´¢å¼•
InterviewRoomSchema.index({ hostUserId: 1, status: 1 });
InterviewRoomSchema.index({ createdAt: -1 });
```

---

## ğŸ”Œ åç«¯ API è®¾è®¡

### 1. æ¨¡å—ç»“æ„

```
backend/src/modules/interview/
â”œâ”€â”€ interview.module.ts          # æ¨¡å—å®šä¹‰
â”œâ”€â”€ interview.controller.ts      # APIæ§åˆ¶å™¨
â”œâ”€â”€ interview.service.ts         # ä¸šåŠ¡é€»è¾‘
â”œâ”€â”€ models/
â”‚   â””â”€â”€ interview-room.entity.ts # é¢è¯•é—´å®ä½“
â””â”€â”€ dto/
    â”œâ”€â”€ create-room.dto.ts       # åˆ›å»ºæˆ¿é—´DTO
    â”œâ”€â”€ query-rooms.dto.ts       # æŸ¥è¯¢æˆ¿é—´DTO
    â””â”€â”€ end-room.dto.ts          # ç»“æŸæˆ¿é—´DTO
```

### 2. DTO å®šä¹‰

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/interview/dto/`

#### create-room.dto.ts
```typescript
import { IsString, IsNotEmpty } from 'class-validator';

export class CreateRoomDto {
  @IsString()
  @IsNotEmpty()
  roomId: string;

  @IsString()
  @IsNotEmpty()
  roomName: string;

  @IsString()
  @IsNotEmpty()
  hostName: string;

  @IsString()
  @IsNotEmpty()
  hostZegoUserId: string; // ZEGOç”¨æˆ·ID
}
```

#### query-rooms.dto.ts
```typescript
import { IsOptional, IsEnum, IsInt, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class QueryRoomsDto {
  @IsOptional()
  @IsEnum(['active', 'ended'])
  status?: 'active' | 'ended';

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  pageSize?: number = 10;

  @IsOptional()
  @IsString()
  search?: string; // æœç´¢æˆ¿é—´åç§°
}
```

#### end-room.dto.ts
```typescript
import { IsString, IsNotEmpty } from 'class-validator';

export class EndRoomDto {
  @IsString()
  @IsNotEmpty()
  roomId: string;
}
```

### 3. Service å®ç°

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/interview/interview.service.ts`

```typescript
import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { InterviewRoom } from './models/interview-room.entity';
import { CreateRoomDto } from './dto/create-room.dto';
import { QueryRoomsDto } from './dto/query-rooms.dto';
import { ZegoService } from '../zego/zego.service';

@Injectable()
export class InterviewService {
  constructor(
    @InjectModel(InterviewRoom.name)
    private readonly roomModel: Model<InterviewRoom>,
    private readonly zegoService: ZegoService,
  ) {}

  /**
   * åˆ›å»ºé¢è¯•é—´ï¼ˆåŒæ—¶åˆ›å»ºæ•°æ®åº“è®°å½•å’Œå†…å­˜æˆ¿é—´ï¼‰
   */
  async createRoom(dto: CreateRoomDto, hostUserId: string): Promise<InterviewRoom> {
    // 1. åˆ›å»ºæ•°æ®åº“è®°å½•
    const room = new this.roomModel({
      roomId: dto.roomId,
      roomName: dto.roomName,
      hostUserId: new Types.ObjectId(hostUserId),
      hostName: dto.hostName,
      hostZegoUserId: dto.hostZegoUserId,
      status: 'active',
      createdAt: new Date(),
      participants: [
        {
          userId: dto.hostZegoUserId,
          userName: dto.hostName,
          role: 'host',
          joinedAt: new Date(),
        },
      ],
    });

    await room.save();

    // 2. åˆ›å»º ZEGO å†…å­˜æˆ¿é—´
    this.zegoService.createRoom(dto.roomId, dto.hostZegoUserId);

    return room;
  }

  /**
   * è·å–ç”¨æˆ·çš„é¢è¯•é—´åˆ—è¡¨ï¼ˆåªè¿”å›è‡ªå·±åˆ›å»ºçš„ï¼‰
   */
  async findByHostUserId(userId: string, query: QueryRoomsDto) {
    const { page = 1, pageSize = 10, status, search } = query;

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const filter: any = {
      hostUserId: new Types.ObjectId(userId), // âœ… å¼ºåˆ¶è¿‡æ»¤ï¼Œåªè¿”å›å½“å‰ç”¨æˆ·çš„
    };

    if (status) {
      filter.status = status;
    }

    if (search) {
      filter.roomName = { $regex: search, $options: 'i' };
    }

    // æŸ¥è¯¢æ•°æ®
    const [list, total] = await Promise.all([
      this.roomModel
        .find(filter)
        .sort({ createdAt: -1 })
        .skip((page - 1) * pageSize)
        .limit(pageSize)
        .lean()
        .exec(),
      this.roomModel.countDocuments(filter),
    ]);

    return {
      list,
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize),
    };
  }

  /**
   * è·å–é¢è¯•é—´è¯¦æƒ…ï¼ˆéªŒè¯æ‰€æœ‰æƒï¼‰
   */
  async findOne(roomId: string, userId: string): Promise<InterviewRoom> {
    const room = await this.roomModel.findOne({ roomId }).lean().exec();

    if (!room) {
      throw new NotFoundException('é¢è¯•é—´ä¸å­˜åœ¨');
    }

    // âœ… éªŒè¯æ‰€æœ‰æƒ
    if (room.hostUserId.toString() !== userId) {
      throw new ForbiddenException('æ— æƒè®¿é—®æ­¤é¢è¯•é—´');
    }

    return room;
  }

  /**
   * ç»“æŸé¢è¯•é—´ï¼ˆéªŒè¯æ‰€æœ‰æƒï¼ŒåŒæ—¶æ›´æ–°æ•°æ®åº“å’Œè§£æ•£å†…å­˜æˆ¿é—´ï¼‰
   */
  async endRoom(roomId: string, userId: string): Promise<InterviewRoom> {
    const room = await this.roomModel.findOne({ roomId });

    if (!room) {
      throw new NotFoundException('é¢è¯•é—´ä¸å­˜åœ¨');
    }

    // âœ… éªŒè¯æ‰€æœ‰æƒ
    if (room.hostUserId.toString() !== userId) {
      throw new ForbiddenException('åªæœ‰åˆ›å»ºè€…å¯ä»¥ç»“æŸé¢è¯•é—´');
    }

    // æ£€æŸ¥æ˜¯å¦å·²ç»“æŸ
    if (room.status === 'ended') {
      throw new ForbiddenException('é¢è¯•é—´å·²ç»“æŸ');
    }

    // 1. æ›´æ–°æ•°æ®åº“çŠ¶æ€
    room.status = 'ended';
    room.endedAt = new Date();
    room.duration = Math.floor(
      (room.endedAt.getTime() - room.createdAt.getTime()) / 1000,
    );

    await room.save();

    // 2. è§£æ•£ ZEGO å†…å­˜æˆ¿é—´
    try {
      await this.zegoService.dismissRoom(roomId, room.hostZegoUserId);
    } catch (error) {
      console.error('è§£æ•£ZEGOæˆ¿é—´å¤±è´¥:', error);
      // å³ä½¿è§£æ•£å¤±è´¥ï¼Œæ•°æ®åº“çŠ¶æ€ä¹Ÿå·²æ›´æ–°
    }

    return room;
  }

  /**
   * æ£€æŸ¥æˆ¿é—´æ˜¯å¦å¯ä»¥é‡æ–°è¿›å…¥
   */
  async checkRoomStatus(roomId: string, userId: string) {
    const room = await this.roomModel.findOne({ roomId }).lean().exec();

    if (!room) {
      return {
        exists: false,
        canJoin: false,
        reason: 'é¢è¯•é—´ä¸å­˜åœ¨',
      };
    }

    // âœ… éªŒè¯æ‰€æœ‰æƒ
    if (room.hostUserId.toString() !== userId) {
      return {
        exists: true,
        canJoin: false,
        reason: 'æ— æƒè®¿é—®æ­¤é¢è¯•é—´',
      };
    }

    if (room.status === 'ended') {
      return {
        exists: true,
        canJoin: false,
        reason: 'é¢è¯•é—´å·²ç»“æŸ',
      };
    }

    // æ£€æŸ¥ ZEGO å†…å­˜æˆ¿é—´çŠ¶æ€
    const zegoStatus = this.zegoService.checkRoom(roomId);

    return {
      exists: true,
      canJoin: zegoStatus.canJoin,
      reason: zegoStatus.canJoin ? 'å¯ä»¥è¿›å…¥' : 'æˆ¿é—´å·²è§£æ•£',
      room,
    };
  }
}
```

### 4. Controller å®ç°

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/interview/interview.controller.ts`

```typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Query,
  Param,
  UseGuards,
  Request,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { InterviewService } from './interview.service';
import { CreateRoomDto } from './dto/create-room.dto';
import { QueryRoomsDto } from './dto/query-rooms.dto';
import { EndRoomDto } from './dto/end-room.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('interview')
@UseGuards(JwtAuthGuard) // âœ… æ‰€æœ‰æ¥å£éƒ½éœ€è¦ç™»å½•
export class InterviewController {
  constructor(private readonly interviewService: InterviewService) {}

  /**
   * åˆ›å»ºé¢è¯•é—´
   */
  @Post('rooms')
  async createRoom(@Body() dto: CreateRoomDto, @Request() req) {
    try {
      const userId = req.user.userId; // ä»JWTè·å–å½“å‰ç”¨æˆ·ID
      const room = await this.interviewService.createRoom(dto, userId);

      return {
        success: true,
        data: room,
        message: 'é¢è¯•é—´åˆ›å»ºæˆåŠŸ',
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: error.message || 'åˆ›å»ºé¢è¯•é—´å¤±è´¥',
          error: 'CREATE_FAILED',
        },
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  /**
   * è·å–é¢è¯•é—´åˆ—è¡¨ï¼ˆåªè¿”å›å½“å‰ç”¨æˆ·åˆ›å»ºçš„ï¼‰
   */
  @Get('rooms')
  async getRooms(@Query() query: QueryRoomsDto, @Request() req) {
    try {
      const userId = req.user.userId;
      const result = await this.interviewService.findByHostUserId(userId, query);

      return {
        success: true,
        data: result,
        message: 'è·å–æˆåŠŸ',
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: error.message || 'è·å–é¢è¯•é—´åˆ—è¡¨å¤±è´¥',
          error: 'QUERY_FAILED',
        },
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  /**
   * è·å–é¢è¯•é—´è¯¦æƒ…
   */
  @Get('rooms/:roomId')
  async getRoomDetail(@Param('roomId') roomId: string, @Request() req) {
    try {
      const userId = req.user.userId;
      const room = await this.interviewService.findOne(roomId, userId);

      return {
        success: true,
        data: room,
        message: 'è·å–æˆåŠŸ',
      };
    } catch (error) {
      const status =
        error.status === 403 || error.status === 404
          ? error.status
          : HttpStatus.BAD_REQUEST;

      throw new HttpException(
        {
          success: false,
          message: error.message || 'è·å–é¢è¯•é—´è¯¦æƒ…å¤±è´¥',
          error: error.name || 'QUERY_FAILED',
        },
        status,
      );
    }
  }

  /**
   * ç»“æŸé¢è¯•é—´
   */
  @Post('rooms/:roomId/end')
  async endRoom(@Param('roomId') roomId: string, @Request() req) {
    try {
      const userId = req.user.userId;
      const room = await this.interviewService.endRoom(roomId, userId);

      return {
        success: true,
        data: room,
        message: 'é¢è¯•é—´å·²ç»“æŸ',
      };
    } catch (error) {
      const status =
        error.status === 403 || error.status === 404
          ? error.status
          : HttpStatus.BAD_REQUEST;

      throw new HttpException(
        {
          success: false,
          message: error.message || 'ç»“æŸé¢è¯•é—´å¤±è´¥',
          error: error.name || 'END_FAILED',
        },
        status,
      );
    }
  }

  /**
   * æ£€æŸ¥æˆ¿é—´çŠ¶æ€ï¼ˆç”¨äºé‡æ–°è¿›å…¥ï¼‰
   */
  @Get('rooms/:roomId/status')
  async checkRoomStatus(@Param('roomId') roomId: string, @Request() req) {
    try {
      const userId = req.user.userId;
      const status = await this.interviewService.checkRoomStatus(roomId, userId);

      return {
        success: true,
        data: status,
        message: 'æ£€æŸ¥æˆåŠŸ',
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: error.message || 'æ£€æŸ¥æˆ¿é—´çŠ¶æ€å¤±è´¥',
          error: 'CHECK_FAILED',
        },
        HttpStatus.BAD_REQUEST,
      );
    }
  }
}
```

### 5. Module å®šä¹‰

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/interview/interview.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { InterviewController } from './interview.controller';
import { InterviewService } from './interview.service';
import { InterviewRoom, InterviewRoomSchema } from './models/interview-room.entity';
import { ZegoModule } from '../zego/zego.module';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: InterviewRoom.name, schema: InterviewRoomSchema },
    ]),
    ZegoModule, // å¯¼å…¥ ZegoModule ä»¥ä½¿ç”¨ ZegoService
  ],
  controllers: [InterviewController],
  providers: [InterviewService],
  exports: [InterviewService],
})
export class InterviewModule {}
```

### 6. æ³¨å†Œæ¨¡å—

**æ–‡ä»¶ä½ç½®**: `backend/src/app.module.ts`

åœ¨ `imports` æ•°ç»„ä¸­æ·»åŠ ï¼š

```typescript
import { InterviewModule } from './modules/interview/interview.module';

@Module({
  imports: [
    // ... å…¶ä»–æ¨¡å—
    InterviewModule, // âœ… æ·»åŠ è¿™ä¸€è¡Œ
  ],
  // ...
})
export class AppModule {}
```

---

## ğŸ¨ å‰ç«¯å®ç°

### 1. é¡µé¢ç»“æ„

```
frontend/src/pages/interview/
â”œâ”€â”€ InterviewRoomList.tsx        # é¢è¯•é—´åˆ—è¡¨é¡µ
â”œâ”€â”€ InterviewRoomList.css        # åˆ—è¡¨é¡µæ ·å¼
â””â”€â”€ components/
    â”œâ”€â”€ RoomCard.tsx             # æˆ¿é—´å¡ç‰‡ç»„ä»¶
    â””â”€â”€ RoomStatusBadge.tsx      # çŠ¶æ€å¾½ç« ç»„ä»¶
```

### 2. ç±»å‹å®šä¹‰

**æ–‡ä»¶ä½ç½®**: `frontend/src/types/interview.types.ts`

```typescript
export interface Participant {
  userId: string;
  userName: string;
  role: 'host' | 'guest';
  identity?: string;
  joinedAt: string;
  leftAt?: string;
}

export interface InterviewRoom {
  _id: string;
  roomId: string;
  roomName: string;
  hostUserId: string;
  hostName: string;
  hostZegoUserId: string;
  status: 'active' | 'ended';
  createdAt: string;
  endedAt?: string;
  duration?: number;
  participants: Participant[];
}

export interface RoomListResponse {
  list: InterviewRoom[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

export interface RoomStatusResponse {
  exists: boolean;
  canJoin: boolean;
  reason: string;
  room?: InterviewRoom;
}
```

### 3. API Service

**æ–‡ä»¶ä½ç½®**: `frontend/src/services/interview.service.ts`

```typescript
import apiService from './api';
import { RoomListResponse, InterviewRoom, RoomStatusResponse } from '../types/interview.types';

export const interviewService = {
  /**
   * åˆ›å»ºé¢è¯•é—´
   */
  async createRoom(data: {
    roomId: string;
    roomName: string;
    hostName: string;
    hostZegoUserId: string;
  }): Promise<{ success: boolean; data: InterviewRoom; message: string }> {
    return apiService.post('/api/interview/rooms', data);
  },

  /**
   * è·å–é¢è¯•é—´åˆ—è¡¨
   */
  async getRooms(params: {
    page?: number;
    pageSize?: number;
    status?: 'active' | 'ended';
    search?: string;
  }): Promise<{ success: boolean; data: RoomListResponse; message: string }> {
    return apiService.get('/api/interview/rooms', { params });
  },

  /**
   * è·å–é¢è¯•é—´è¯¦æƒ…
   */
  async getRoomDetail(roomId: string): Promise<{ success: boolean; data: InterviewRoom; message: string }> {
    return apiService.get(`/api/interview/rooms/${roomId}`);
  },

  /**
   * ç»“æŸé¢è¯•é—´
   */
  async endRoom(roomId: string): Promise<{ success: boolean; data: InterviewRoom; message: string }> {
    return apiService.post(`/api/interview/rooms/${roomId}/end`);
  },

  /**
   * æ£€æŸ¥æˆ¿é—´çŠ¶æ€
   */
  async checkRoomStatus(roomId: string): Promise<{ success: boolean; data: RoomStatusResponse; message: string }> {
    return apiService.get(`/api/interview/rooms/${roomId}/status`);
  },
};
```

### 4. çŠ¶æ€å¾½ç« ç»„ä»¶

**æ–‡ä»¶ä½ç½®**: `frontend/src/pages/interview/components/RoomStatusBadge.tsx`

```typescript
import React from 'react';
import { Tag } from 'antd';

interface RoomStatusBadgeProps {
  status: 'active' | 'ended';
}

const RoomStatusBadge: React.FC<RoomStatusBadgeProps> = ({ status }) => {
  if (status === 'active') {
    return <Tag color="success">ğŸŸ¢ è¿›è¡Œä¸­</Tag>;
  }
  return <Tag color="default">ğŸ”´ å·²ç»“æŸ</Tag>;
};

export default RoomStatusBadge;
```

### 5. æˆ¿é—´å¡ç‰‡ç»„ä»¶

**æ–‡ä»¶ä½ç½®**: `frontend/src/pages/interview/components/RoomCard.tsx`

```typescript
import React from 'react';
import { Card, Button, Space, Typography, Descriptions, Modal, message } from 'antd';
import { ClockCircleOutlined, UserOutlined, VideoCameraOutlined } from '@ant-design/icons';
import { InterviewRoom } from '../../../types/interview.types';
import RoomStatusBadge from './RoomStatusBadge';
import dayjs from 'dayjs';
import duration from 'dayjs/plugin/duration';

dayjs.extend(duration);

const { Text } = Typography;

interface RoomCardProps {
  room: InterviewRoom;
  onRejoin: (roomId: string) => void;
  onEnd: (roomId: string) => void;
  onViewDetail: (roomId: string) => void;
}

const RoomCard: React.FC<RoomCardProps> = ({ room, onRejoin, onEnd, onViewDetail }) => {
  // æ ¼å¼åŒ–æ—¶é•¿
  const formatDuration = (seconds?: number) => {
    if (!seconds) return '-';
    const d = dayjs.duration(seconds, 'seconds');
    const hours = Math.floor(d.asHours());
    const minutes = d.minutes();
    if (hours > 0) {
      return `${hours}å°æ—¶${minutes}åˆ†é’Ÿ`;
    }
    return `${minutes}åˆ†é’Ÿ`;
  };

  // è®¡ç®—è¿›è¡Œä¸­çš„æ—¶é•¿
  const getActiveDuration = () => {
    if (room.status === 'ended' && room.duration) {
      return formatDuration(room.duration);
    }
    if (room.status === 'active') {
      const now = dayjs();
      const start = dayjs(room.createdAt);
      const seconds = now.diff(start, 'seconds');
      return formatDuration(seconds);
    }
    return '-';
  };

  // ç¡®è®¤ç»“æŸé¢è¯•
  const handleEnd = () => {
    Modal.confirm({
      title: 'ç¡®è®¤ç»“æŸé¢è¯•é—´',
      content: 'ç»“æŸåï¼Œæ‰€æœ‰å‚ä¸è€…å°†è¢«å¼ºåˆ¶ç¦»å¼€ï¼Œæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼',
      okText: 'ç¡®è®¤ç»“æŸ',
      cancelText: 'å–æ¶ˆ',
      okButtonProps: { danger: true },
      onOk: () => onEnd(room.roomId),
    });
  };

  return (
    <Card
      hoverable
      style={{ marginBottom: 16 }}
      title={
        <Space>
          <RoomStatusBadge status={room.status} />
          <Text strong>{room.roomName}</Text>
        </Space>
      }
      extra={
        <Text type="secondary" style={{ fontSize: 12 }}>
          æˆ¿é—´å·: {room.roomId.split('_')[1]?.substring(0, 10) || room.roomId}
        </Text>
      }
    >
      <Descriptions column={2} size="small">
        <Descriptions.Item label={<><ClockCircleOutlined /> åˆ›å»ºæ—¶é—´</>}>
          {dayjs(room.createdAt).format('YYYY-MM-DD HH:mm')}
        </Descriptions.Item>
        <Descriptions.Item label={<><ClockCircleOutlined /> æŒç»­æ—¶é•¿</>}>
          {getActiveDuration()}
        </Descriptions.Item>
        {room.status === 'ended' && room.endedAt && (
          <Descriptions.Item label={<><ClockCircleOutlined /> ç»“æŸæ—¶é—´</>}>
            {dayjs(room.endedAt).format('YYYY-MM-DD HH:mm')}
          </Descriptions.Item>
        )}
        <Descriptions.Item label={<><UserOutlined /> å‚ä¸è€…</>}>
          {room.participants.length} äºº
          {room.participants.length > 0 && (
            <Text type="secondary" style={{ marginLeft: 8, fontSize: 12 }}>
              ({room.participants.map(p => p.userName).join(', ')})
            </Text>
          )}
        </Descriptions.Item>
      </Descriptions>

      <div style={{ marginTop: 16, textAlign: 'right' }}>
        <Space>
          {room.status === 'active' && (
            <>
              <Button
                type="primary"
                icon={<VideoCameraOutlined />}
                onClick={() => onRejoin(room.roomId)}
              >
                é‡æ–°è¿›å…¥
              </Button>
              <Button danger onClick={handleEnd}>
                ç»“æŸé¢è¯•
              </Button>
            </>
          )}
          <Button onClick={() => onViewDetail(room.roomId)}>
            æŸ¥çœ‹è¯¦æƒ…
          </Button>
        </Space>
      </div>
    </Card>
  );
};

export default RoomCard;
```

### 6. é¢è¯•é—´åˆ—è¡¨é¡µé¢

**æ–‡ä»¶ä½ç½®**: `frontend/src/pages/interview/InterviewRoomList.tsx`

```typescript
import React, { useState, useEffect } from 'react';
import {
  Card,
  Tabs,
  Input,
  Pagination,
  Empty,
  Spin,
  message,
  Button,
  Space,
} from 'antd';
import { SearchOutlined, PlusOutlined, ReloadOutlined } from '@ant-design/icons';
import { useNavigate } from 'react-router-dom';
import { interviewService } from '../../services/interview.service';
import { InterviewRoom } from '../../types/interview.types';
import RoomCard from './components/RoomCard';
import './InterviewRoomList.css';

const { TabPane } = Tabs;
const { Search } = Input;

const InterviewRoomList: React.FC = () => {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [rooms, setRooms] = useState<InterviewRoom[]>([]);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(1);
  const [pageSize] = useState(10);
  const [status, setStatus] = useState<'all' | 'active' | 'ended'>('all');
  const [searchText, setSearchText] = useState('');

  // åŠ è½½æˆ¿é—´åˆ—è¡¨
  const loadRooms = async () => {
    setLoading(true);
    try {
      const params: any = { page, pageSize };
      if (status !== 'all') {
        params.status = status;
      }
      if (searchText) {
        params.search = searchText;
      }

      const response = await interviewService.getRooms(params);
      if (response.success) {
        setRooms(response.data.list);
        setTotal(response.data.total);
      }
    } catch (error: any) {
      message.error(error.message || 'åŠ è½½å¤±è´¥');
    } finally {
      setLoading(false);
    }
  };

  // åˆå§‹åŠ è½½å’Œä¾èµ–æ›´æ–°
  useEffect(() => {
    loadRooms();
  }, [page, status, searchText]);

  // åˆ‡æ¢æ ‡ç­¾
  const handleTabChange = (key: string) => {
    setStatus(key as 'all' | 'active' | 'ended');
    setPage(1);
  };

  // æœç´¢
  const handleSearch = (value: string) => {
    setSearchText(value);
    setPage(1);
  };

  // é‡æ–°è¿›å…¥æˆ¿é—´
  const handleRejoin = async (roomId: string) => {
    try {
      // æ£€æŸ¥æˆ¿é—´çŠ¶æ€
      const response = await interviewService.checkRoomStatus(roomId);
      if (response.success && response.data.canJoin) {
        // è·³è½¬åˆ°é¢è¯•é—´
        navigate(`/interview/room/${roomId}`);
      } else {
        message.warning(response.data.reason || 'æ— æ³•è¿›å…¥æˆ¿é—´');
      }
    } catch (error: any) {
      message.error(error.message || 'æ£€æŸ¥æˆ¿é—´çŠ¶æ€å¤±è´¥');
    }
  };

  // ç»“æŸé¢è¯•
  const handleEnd = async (roomId: string) => {
    try {
      const response = await interviewService.endRoom(roomId);
      if (response.success) {
        message.success('é¢è¯•é—´å·²ç»“æŸ');
        loadRooms(); // åˆ·æ–°åˆ—è¡¨
      }
    } catch (error: any) {
      message.error(error.message || 'ç»“æŸé¢è¯•é—´å¤±è´¥');
    }
  };

  // æŸ¥çœ‹è¯¦æƒ…
  const handleViewDetail = (roomId: string) => {
    navigate(`/interview/room/${roomId}/detail`);
  };

  // åˆ›å»ºæ–°é¢è¯•é—´
  const handleCreateRoom = () => {
    navigate('/interview/pc');
  };

  return (
    <div className="interview-room-list">
      <Card
        title="é¢è¯•é—´åˆ—è¡¨"
        extra={
          <Space>
            <Button
              type="primary"
              icon={<PlusOutlined />}
              onClick={handleCreateRoom}
            >
              åˆ›å»ºæ–°é¢è¯•é—´
            </Button>
            <Button icon={<ReloadOutlined />} onClick={loadRooms}>
              åˆ·æ–°
            </Button>
          </Space>
        }
      >
        {/* æœç´¢æ  */}
        <div style={{ marginBottom: 16 }}>
          <Search
            placeholder="æœç´¢æˆ¿é—´åç§°"
            allowClear
            enterButton={<SearchOutlined />}
            onSearch={handleSearch}
            style={{ maxWidth: 400 }}
          />
        </div>

        {/* çŠ¶æ€æ ‡ç­¾ */}
        <Tabs activeKey={status} onChange={handleTabChange}>
          <TabPane tab="å…¨éƒ¨" key="all" />
          <TabPane tab="è¿›è¡Œä¸­" key="active" />
          <TabPane tab="å·²ç»“æŸ" key="ended" />
        </Tabs>

        {/* æˆ¿é—´åˆ—è¡¨ */}
        <Spin spinning={loading}>
          {rooms.length === 0 ? (
            <Empty
              description={
                searchText ? 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„é¢è¯•é—´' : 'æš‚æ— é¢è¯•é—´è®°å½•'
              }
              style={{ padding: '60px 0' }}
            >
              {!searchText && (
                <Button type="primary" onClick={handleCreateRoom}>
                  åˆ›å»ºç¬¬ä¸€ä¸ªé¢è¯•é—´
                </Button>
              )}
            </Empty>
          ) : (
            <>
              {rooms.map((room) => (
                <RoomCard
                  key={room._id}
                  room={room}
                  onRejoin={handleRejoin}
                  onEnd={handleEnd}
                  onViewDetail={handleViewDetail}
                />
              ))}

              {/* åˆ†é¡µ */}
              <div style={{ marginTop: 24, textAlign: 'right' }}>
                <Pagination
                  current={page}
                  pageSize={pageSize}
                  total={total}
                  onChange={setPage}
                  showSizeChanger={false}
                  showTotal={(total) => `å…± ${total} æ¡è®°å½•`}
                />
              </div>
            </>
          )}
        </Spin>
      </Card>
    </div>
  );
};

export default InterviewRoomList;
```

### 7. æ ·å¼æ–‡ä»¶

**æ–‡ä»¶ä½ç½®**: `frontend/src/pages/interview/InterviewRoomList.css`

```css
.interview-room-list {
  padding: 24px;
  background: #f0f2f5;
  min-height: calc(100vh - 64px);
}

.interview-room-list .ant-card {
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.interview-room-list .ant-descriptions-item-label {
  font-weight: 500;
  color: rgba(0, 0, 0, 0.65);
}

.interview-room-list .ant-card-head {
  border-bottom: 1px solid #f0f0f0;
}

.interview-room-list .ant-empty {
  margin: 40px 0;
}
```

### 8. è·¯ç”±é…ç½®

**æ–‡ä»¶ä½ç½®**: `frontend/src/App.tsx` æˆ– `frontend/src/router.tsx`

```typescript
import InterviewRoomList from './pages/interview/InterviewRoomList';

// åœ¨è·¯ç”±é…ç½®ä¸­æ·»åŠ 
{
  path: '/interview/rooms',
  element: <InterviewRoomList />,
}
```

### 9. èœå•é…ç½®

**æ–‡ä»¶ä½ç½®**: `frontend/src/layouts/BasicLayout.tsx`

åœ¨è§†é¢‘é¢è¯•èœå•ä¸‹æ·»åŠ ï¼š

```typescript
{
  path: '/interview',
  name: 'è§†é¢‘é¢è¯•',
  icon: <VideoCameraOutlined />,
  children: [
    {
      path: '/interview/rooms',
      name: 'é¢è¯•é—´åˆ—è¡¨',
      icon: <UnorderedListOutlined />,
    },
    {
      path: '/interview/pc',
      name: 'PCç«¯é¢è¯•',
      icon: <DesktopOutlined />,
    },
    // ... å…¶ä»–èœå•é¡¹
  ],
}
```

---

## ğŸ”„ æ•´åˆç°æœ‰åˆ›å»ºæµç¨‹

### ä¿®æ”¹ ZEGO Controller

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/zego/zego.controller.ts`

åœ¨ `generateToken` æ–¹æ³•ä¸­ï¼Œåˆ›å»ºæˆ¿é—´æ—¶åŒæ—¶å†™å…¥æ•°æ®åº“ï¼š

```typescript
import { InterviewService } from '../interview/interview.service';

@Controller('zego')
export class ZegoController {
  constructor(
    private readonly zegoService: ZegoService,
    private readonly interviewService: InterviewService, // âœ… æ³¨å…¥ InterviewService
  ) {}

  @Post('generate-token')
  @UseGuards(JwtAuthGuard)
  async generateToken(@Body() body: GenerateTokenDto, @Request() req) {
    const { roomId, userId, userName, role } = body;
    const currentUserId = req.user.userId; // ä»JWTè·å–å½“å‰ç”¨æˆ·ID

    try {
      // 1. ç”Ÿæˆ ZEGO Token
      const token = this.zegoService.generateToken(roomId, userId);

      // 2. å¦‚æœæ˜¯ä¸»æŒäººåˆ›å»ºæˆ¿é—´ï¼ŒåŒæ—¶å†™å…¥æ•°æ®åº“
      if (role === 'host') {
        await this.interviewService.createRoom(
          {
            roomId,
            roomName: `é¢è¯•é—´-${new Date().toLocaleString('zh-CN')}`,
            hostName: userName,
            hostZegoUserId: userId,
          },
          currentUserId,
        );
      }

      return {
        success: true,
        data: {
          token,
          appId: this.zegoService.getAppId(),
          roomId,
          userId,
        },
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: error.message || 'ç”ŸæˆTokenå¤±è´¥',
        },
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  // ... å…¶ä»–æ–¹æ³•
}
```

### ä¿®æ”¹ ZEGO Module

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/zego/zego.module.ts`

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { ZegoController } from './zego.controller';
import { ZegoService } from './zego.service';
import { InterviewModule } from '../interview/interview.module';

@Module({
  imports: [
    forwardRef(() => InterviewModule), // âœ… ä½¿ç”¨ forwardRef é¿å…å¾ªç¯ä¾èµ–
  ],
  controllers: [ZegoController],
  providers: [ZegoService],
  exports: [ZegoService],
})
export class ZegoModule {}
```

### ä¿®æ”¹ Interview Module

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/interview/interview.module.ts`

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { InterviewController } from './interview.controller';
import { InterviewService } from './interview.service';
import { InterviewRoom, InterviewRoomSchema } from './models/interview-room.entity';
import { ZegoModule } from '../zego/zego.module';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: InterviewRoom.name, schema: InterviewRoomSchema },
    ]),
    forwardRef(() => ZegoModule), // âœ… ä½¿ç”¨ forwardRef é¿å…å¾ªç¯ä¾èµ–
  ],
  controllers: [InterviewController],
  providers: [InterviewService],
  exports: [InterviewService],
})
export class InterviewModule {}
```

---

## ğŸ”§ ZegoService å¢å¼º

**æ–‡ä»¶ä½ç½®**: `backend/src/modules/zego/zego.service.ts`

æ·»åŠ æ£€æŸ¥æˆ¿é—´çŠ¶æ€çš„æ–¹æ³•ï¼š

```typescript
/**
 * æ£€æŸ¥æˆ¿é—´çŠ¶æ€
 */
checkRoom(roomId: string): { exists: boolean; canJoin: boolean } {
  const room = this.rooms.get(roomId);

  if (!room) {
    return { exists: false, canJoin: false };
  }

  // æ£€æŸ¥æˆ¿é—´æ˜¯å¦å·²è§£æ•£
  if (room.status === 'dismissed') {
    return { exists: true, canJoin: false };
  }

  return { exists: true, canJoin: true };
}
```

---

## âœ… å¼€å‘æ£€æŸ¥æ¸…å•

### åç«¯å¼€å‘ï¼ˆé¢„è®¡ 3-4 å°æ—¶ï¼‰

- [ ] **åˆ›å»ºæ•°æ®æ¨¡å‹**
  - [ ] `interview-room.entity.ts` - é¢è¯•é—´å®ä½“
  - [ ] `participant.schema.ts` - å‚ä¸è€…å­æ–‡æ¡£

- [ ] **åˆ›å»º DTO**
  - [ ] `create-room.dto.ts`
  - [ ] `query-rooms.dto.ts`
  - [ ] `end-room.dto.ts`

- [ ] **å®ç° Service**
  - [ ] `createRoom()` - åˆ›å»ºé¢è¯•é—´
  - [ ] `findByHostUserId()` - è·å–åˆ—è¡¨ï¼ˆæƒé™è¿‡æ»¤ï¼‰
  - [ ] `findOne()` - è·å–è¯¦æƒ…ï¼ˆæƒé™éªŒè¯ï¼‰
  - [ ] `endRoom()` - ç»“æŸé¢è¯•é—´ï¼ˆæƒé™éªŒè¯ï¼‰
  - [ ] `checkRoomStatus()` - æ£€æŸ¥çŠ¶æ€

- [ ] **å®ç° Controller**
  - [ ] `POST /interview/rooms` - åˆ›å»º
  - [ ] `GET /interview/rooms` - åˆ—è¡¨
  - [ ] `GET /interview/rooms/:roomId` - è¯¦æƒ…
  - [ ] `POST /interview/rooms/:roomId/end` - ç»“æŸ
  - [ ] `GET /interview/rooms/:roomId/status` - çŠ¶æ€æ£€æŸ¥

- [ ] **æ¨¡å—é…ç½®**
  - [ ] åˆ›å»º `interview.module.ts`
  - [ ] åœ¨ `app.module.ts` ä¸­æ³¨å†Œ
  - [ ] é…ç½® `forwardRef` é¿å…å¾ªç¯ä¾èµ–

- [ ] **æ•´åˆç°æœ‰æµç¨‹**
  - [ ] ä¿®æ”¹ `zego.controller.ts` çš„ `generateToken()`
  - [ ] ä¿®æ”¹ `zego.service.ts` æ·»åŠ  `checkRoom()`
  - [ ] æ›´æ–°æ¨¡å—ä¾èµ–å…³ç³»

### å‰ç«¯å¼€å‘ï¼ˆé¢„è®¡ 3-4 å°æ—¶ï¼‰

- [ ] **ç±»å‹å®šä¹‰**
  - [ ] `interview.types.ts` - å®šä¹‰æ¥å£ç±»å‹

- [ ] **API Service**
  - [ ] `interview.service.ts` - å°è£… API è°ƒç”¨

- [ ] **ç»„ä»¶å¼€å‘**
  - [ ] `RoomStatusBadge.tsx` - çŠ¶æ€å¾½ç« 
  - [ ] `RoomCard.tsx` - æˆ¿é—´å¡ç‰‡
  - [ ] `InterviewRoomList.tsx` - åˆ—è¡¨é¡µé¢
  - [ ] `InterviewRoomList.css` - æ ·å¼

- [ ] **è·¯ç”±é…ç½®**
  - [ ] æ·»åŠ  `/interview/rooms` è·¯ç”±
  - [ ] åœ¨ä¾§è¾¹æ èœå•ä¸­æ·»åŠ å…¥å£

- [ ] **åŠŸèƒ½æµ‹è¯•**
  - [ ] åˆ—è¡¨åŠ è½½
  - [ ] çŠ¶æ€ç­›é€‰
  - [ ] æœç´¢åŠŸèƒ½
  - [ ] é‡æ–°è¿›å…¥
  - [ ] ç»“æŸé¢è¯•
  - [ ] åˆ†é¡µåŠŸèƒ½

### æµ‹è¯•éªŒè¯ï¼ˆé¢„è®¡ 1-2 å°æ—¶ï¼‰

- [ ] **æƒé™æµ‹è¯•**
  - [ ] ç”¨æˆ·Aåªèƒ½çœ‹åˆ°è‡ªå·±çš„é¢è¯•é—´
  - [ ] ç”¨æˆ·Bæ— æ³•è®¿é—®ç”¨æˆ·Açš„é¢è¯•é—´
  - [ ] æœªç™»å½•ç”¨æˆ·æ— æ³•è®¿é—®

- [ ] **åŠŸèƒ½æµ‹è¯•**
  - [ ] åˆ›å»ºé¢è¯•é—´åè‡ªåŠ¨å‡ºç°åœ¨åˆ—è¡¨
  - [ ] è¿›è¡Œä¸­çš„é¢è¯•é—´å¯ä»¥é‡æ–°è¿›å…¥
  - [ ] ç»“æŸé¢è¯•é—´åçŠ¶æ€æ­£ç¡®æ›´æ–°
  - [ ] æ—¶é•¿è®¡ç®—æ­£ç¡®

- [ ] **è¾¹ç•Œæµ‹è¯•**
  - [ ] ç©ºåˆ—è¡¨æ˜¾ç¤º
  - [ ] æœç´¢æ— ç»“æœ
  - [ ] åˆ†é¡µè¾¹ç•Œ
  - [ ] ç½‘ç»œé”™è¯¯å¤„ç†

---

## ğŸ“ å¼€å‘æ³¨æ„äº‹é¡¹

### 1. æƒé™æ§åˆ¶è¦ç‚¹

âœ… **å¿…é¡»åšåˆ°**ï¼š
- æ‰€æœ‰ API éƒ½ä½¿ç”¨ `@UseGuards(JwtAuthGuard)`
- æ‰€æœ‰æŸ¥è¯¢éƒ½è¿‡æ»¤ `hostUserId === req.user.userId`
- æ‰€æœ‰æ“ä½œéƒ½éªŒè¯æ‰€æœ‰æƒ

âŒ **ç»å¯¹ä¸èƒ½**ï¼š
- ç›´æ¥ä½¿ç”¨å‰ç«¯ä¼ æ¥çš„ `userId`
- è·³è¿‡æƒé™éªŒè¯
- è¿”å›å…¶ä»–ç”¨æˆ·çš„æ•°æ®

### 2. æ•°æ®åŒæ­¥ç­–ç•¥

**åˆ›å»ºæ—¶**ï¼š
```
å‰ç«¯ â†’ åç«¯ Controller â†’ InterviewService.createRoom()
                       â†“
                  1. å†™å…¥æ•°æ®åº“
                  2. è°ƒç”¨ ZegoService.createRoom()
```

**ç»“æŸæ—¶**ï¼š
```
å‰ç«¯ â†’ åç«¯ Controller â†’ InterviewService.endRoom()
                       â†“
                  1. æ›´æ–°æ•°æ®åº“çŠ¶æ€
                  2. è°ƒç”¨ ZegoService.dismissRoom()
```

### 3. é”™è¯¯å¤„ç†

- ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼
- åŒºåˆ† 404ï¼ˆä¸å­˜åœ¨ï¼‰å’Œ 403ï¼ˆæ— æƒé™ï¼‰
- å‰ç«¯æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º

### 4. æ€§èƒ½ä¼˜åŒ–

- æ•°æ®åº“æŸ¥è¯¢ä½¿ç”¨ç´¢å¼•ï¼ˆ`hostUserId`, `status`, `createdAt`ï¼‰
- åˆ—è¡¨åˆ†é¡µåŠ è½½
- é¿å… N+1 æŸ¥è¯¢é—®é¢˜

---

## ğŸš€ éƒ¨ç½²ä¸Šçº¿

### 1. æ•°æ®åº“è¿ç§»

ç¡®ä¿ MongoDB ä¸­åˆ›å»ºäº† `interview_rooms` é›†åˆå’Œç´¢å¼•ã€‚

### 2. ç¯å¢ƒå˜é‡

æ— éœ€é¢å¤–ç¯å¢ƒå˜é‡ï¼Œä½¿ç”¨ç°æœ‰é…ç½®å³å¯ã€‚

### 3. æµ‹è¯•æµç¨‹

1. åç«¯å¯åŠ¨ï¼š`cd backend && npm run start:dev`
2. å‰ç«¯å¯åŠ¨ï¼š`cd frontend && npm start`
3. ç™»å½•ç³»ç»Ÿ
4. è®¿é—® `/interview/rooms`
5. æµ‹è¯•å„é¡¹åŠŸèƒ½

---

## ğŸ“Š é¢„æœŸæ•ˆæœ

### ç”¨æˆ·ä½“éªŒ

1. **ä¸»æŒäººåˆ›å»ºé¢è¯•é—´**ï¼š
   - ç‚¹å‡»"åˆ›å»ºé¢è¯•é—´" â†’ è‡ªåŠ¨è®°å½•åˆ°æ•°æ®åº“
   - å¯ä»¥åœ¨åˆ—è¡¨ä¸­çœ‹åˆ°"è¿›è¡Œä¸­"çš„é¢è¯•é—´

2. **é‡æ–°è¿›å…¥é¢è¯•é—´**ï¼š
   - å¦‚æœæ„å¤–å…³é—­é¡µé¢ï¼Œå¯ä»¥ä»åˆ—è¡¨é‡æ–°è¿›å…¥
   - ç³»ç»Ÿè‡ªåŠ¨æ£€æŸ¥æˆ¿é—´çŠ¶æ€

3. **ç»“æŸé¢è¯•**ï¼š
   - ç‚¹å‡»"ç»“æŸé¢è¯•" â†’ çŠ¶æ€å˜ä¸º"å·²ç»“æŸ"
   - è®°å½•ç»“æŸæ—¶é—´å’Œæ€»æ—¶é•¿

4. **æŸ¥çœ‹å†å²**ï¼š
   - å¯ä»¥æŸ¥çœ‹æ‰€æœ‰å†å²é¢è¯•è®°å½•
   - æŒ‰æ—¶é—´å€’åºæ’åˆ—

### æ•°æ®éš”ç¦»

- âœ… æ¯ä¸ªç”¨æˆ·åªèƒ½çœ‹åˆ°è‡ªå·±åˆ›å»ºçš„é¢è¯•é—´
- âœ… æ— æ³•è®¿é—®å…¶ä»–ç”¨æˆ·çš„é¢è¯•é—´
- âœ… å®Œå…¨çš„æ•°æ®éš”ç¦»å’Œå®‰å…¨

---

## ğŸ‰ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„é¢è¯•é—´åˆ—è¡¨åŠŸèƒ½å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

1. âœ… **å®Œæ•´çš„æ•°æ®æ¨¡å‹è®¾è®¡**ï¼ˆEntity + DTOï¼‰
2. âœ… **ä¸¥æ ¼çš„æƒé™æ§åˆ¶**ï¼ˆJWT + æ‰€æœ‰æƒéªŒè¯ï¼‰
3. âœ… **å®Œæ•´çš„åç«¯å®ç°**ï¼ˆService + Controller + Moduleï¼‰
4. âœ… **å®Œæ•´çš„å‰ç«¯å®ç°**ï¼ˆé¡µé¢ + ç»„ä»¶ + æ ·å¼ï¼‰
5. âœ… **ä¸ç°æœ‰ç³»ç»Ÿçš„æ•´åˆ**ï¼ˆZEGO Service é›†æˆï¼‰
6. âœ… **è¯¦ç»†çš„å¼€å‘æ£€æŸ¥æ¸…å•**

**é¢„è®¡å¼€å‘æ—¶é—´**ï¼š1-1.5 å¤©ï¼ˆ6-8 å°æ—¶ï¼‰

**æ˜å¤©å¼€å‘é¡ºåºå»ºè®®**ï¼š
1. å…ˆå®Œæˆåç«¯ï¼ˆ3-4å°æ—¶ï¼‰
2. å†å®Œæˆå‰ç«¯ï¼ˆ3-4å°æ—¶ï¼‰
3. æœ€åæµ‹è¯•éªŒè¯ï¼ˆ1-2å°æ—¶ï¼‰

ç¥å¼€å‘é¡ºåˆ©ï¼ğŸš€

