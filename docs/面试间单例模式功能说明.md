# 面试间单例模式功能说明

## 📋 需求背景

### 问题
- 用户实际只需要**一个活跃的面试间**
- 但现在可以创建多个面试间，导致：
  - ❌ 旧的面试间没关闭，状态还是 `active`
  - ❌ 可以同时存在多个 `active` 状态的面试间
  - ❌ 用户可能搞不清楚应该用哪个面试间
  - ❌ 资源浪费（ZEGO 连接、数据库记录）

### 解决方案
**创建新面试间时，自动关闭该用户之前所有未结束的面试间**

---

## 🎯 实现逻辑

### 核心流程
```
用户点击"创建面试间"
    ↓
后端 InterviewService.createRoom() 被调用
    ↓
【第一步】查询该用户是否有 status='active' 的面试间
    ↓
    ├─ 如果有 → 自动关闭这些活跃面试间
    │           ├─ 更新数据库状态为 'ended'
    │           ├─ 记录结束时间和持续时长
    │           ├─ 调用 ZEGO 解散房间（踢出所有参与者）
    │           └─ 清理内存数据
    │
    └─ 如果没有 → 直接进入第二步
    ↓
【第二步】创建新的面试间
    ↓
返回新面试间信息给前端
```

### 代码实现

#### 1. 修改 `createRoom` 方法
```typescript
async createRoom(userId: string, dto: CreateRoomDto): Promise<InterviewRoom> {
  this.logger.log(`创建面试间: ${dto.roomId}, 主持人: ${userId}`);

  // 🔥 第一步：自动关闭该用户所有活跃的面试间（确保只有一个活跃面试间）
  await this.autoCloseUserActiveRooms(userId, dto.hostZegoUserId);

  // 🔥 第二步：创建新的面试间
  const room = new this.interviewRoomModel({...});
  return await room.save();
}
```

#### 2. 新增 `autoCloseUserActiveRooms` 私有方法
```typescript
private async autoCloseUserActiveRooms(userId: string, hostZegoUserId: string): Promise<void> {
  // 1. 查询该用户所有活跃的面试间
  const activeRooms = await this.interviewRoomModel.find({
    hostUserId: new Types.ObjectId(userId),
    status: 'active'
  }).exec();

  if (activeRooms.length === 0) {
    return; // 没有活跃面试间，直接返回
  }

  // 2. 遍历并关闭每个面试间
  for (const room of activeRooms) {
    // 2.1 更新数据库状态
    room.status = 'ended';
    room.endedAt = new Date();
    room.duration = Math.floor((new Date().getTime() - room.createdAt.getTime()) / 1000);
    await room.save();

    // 2.2 调用 ZEGO 服务解散房间
    await this.zegoService.dismissRoom(room.roomId, hostZegoUserId);
  }
}
```

---

## ✅ 功能特性

### 1. 自动清理
- ✅ 无需用户手动关闭旧面试间
- ✅ 创建新面试间时自动处理
- ✅ 用户无感知，体验流畅

### 2. 资源管理
- ✅ 保证同一时间只有一个活跃面试间
- ✅ 自动释放 ZEGO 资源
- ✅ 数据库状态准确

### 3. 数据完整性
- ✅ 自动记录旧面试间的结束时间
- ✅ 自动计算旧面试间的持续时长
- ✅ 保留完整的面试历史记录

### 4. 容错处理
- ✅ 如果 ZEGO 解散失败，不影响数据库状态更新
- ✅ 如果某个旧面试间关闭失败，继续处理下一个
- ✅ 详细的日志记录，便于排查问题

---

## 📊 使用场景

### 场景一：正常创建新面试间
```
用户第一次创建面试间
    ↓
检查：没有活跃面试间
    ↓
直接创建新面试间 ✅
```

### 场景二：旧面试间未关闭，创建新的
```
用户之前创建了面试间，但没有手动关闭
    ↓
用户再次点击"创建面试间"
    ↓
检查：发现1个活跃面试间
    ↓
自动关闭旧面试间（更新数据库 + 解散 ZEGO 房间）
    ↓
创建新面试间 ✅
```

### 场景三：多个旧面试间未关闭
```
用户创建了多个面试间（异常情况）
    ↓
用户再次点击"创建面试间"
    ↓
检查：发现3个活跃面试间
    ↓
遍历关闭所有旧面试间
    ↓
创建新面试间 ✅
```

---

## 🔍 边界情况处理

### 1. 旧面试间还有其他参与者
**处理方式：** 强制关闭，踢出所有参与者

**原因：**
- 主持人是房间的所有者，有权关闭
- 如果旧面试间还在用，主持人不应该创建新的
- 访客会收到"房间已解散"的通知

### 2. ZEGO 解散失败
**处理方式：** 记录警告日志，但不影响数据库状态更新

**原因：**
- 数据库状态是权威数据源
- ZEGO 房间会在10分钟无人后自动清理
- 不应该因为 ZEGO 失败而阻止创建新面试间

### 3. 并发创建
**处理方式：** 数据库查询是实时的，后创建的会关闭先创建的

**原因：**
- 用户最新的意图是使用新创建的面试间
- 前端可以添加防抖避免重复点击

---

## 📝 日志示例

### 没有旧面试间
```
🔍 检查用户 507f1f77bcf86cd799439011 是否有活跃的面试间
✅ 用户 507f1f77bcf86cd799439011 没有活跃的面试间，可以直接创建新面试间
✅ 面试间创建成功: room_abc123
```

### 有旧面试间需要关闭
```
🔍 检查用户 507f1f77bcf86cd799439011 是否有活跃的面试间
🔄 发现 2 个活跃面试间，准备自动关闭
🔄 正在关闭旧面试间: room_old_001
✅ 数据库状态已更新: room_old_001
✅ ZEGO 房间已解散: room_old_001
✅ 已自动关闭旧面试间: room_old_001, 持续时长: 1234秒
🔄 正在关闭旧面试间: room_old_002
✅ 数据库状态已更新: room_old_002
✅ ZEGO 房间已解散: room_old_002
✅ 已自动关闭旧面试间: room_old_002, 持续时长: 567秒
✅ 所有旧面试间已关闭，准备创建新面试间
✅ 面试间创建成功: room_new_003
```

---

## 🚀 部署说明

1. ✅ 无需数据库迁移
2. ✅ 无需前端修改
3. ✅ 向后兼容
4. ✅ 重启后端服务即可生效

---

## 📅 开发日期
2025-11-19

## 👤 开发人员
AI Assistant (Augment Agent)

