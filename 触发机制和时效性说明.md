# 线索分配通知 - 触发机制和时效性说明

> **重要发现**: 当前实现是**被动返回数据**，不是主动推送！

---

## 🔍 当前触发机制分析

### 1️⃣ **CRM端分配接口**（实时触发 ✅）

#### 触发时机
当管理员/经理在CRM系统中执行以下操作时，**立即触发**：

| 操作 | 接口 | 触发时效 |
|------|------|----------|
| Web端单个分配 | `PATCH /api/customers/:id/assign` | **实时** |
| 小程序端单个分配 | `PATCH /api/customers/miniprogram/:id/assign` | **实时** |
| 批量分配 | `POST /api/customers/batch-assign` | **实时** |
| 从公海分配 | `POST /api/customers/public-pool/assign` | **实时** |

#### 执行流程
```
用户点击"分配" 
  ↓ (立即)
调用API接口
  ↓ (立即)
更新数据库
  ↓ (立即)
返回 notificationData
  ↓ (需要前端处理)
前端接收数据
  ↓ (需要前端实现)
发送微信通知
```

**时效性**: ⚡ **毫秒级** - 从点击到返回数据通常在 100-500ms

---

### 2️⃣ **自动流转机制**（定时触发 ⏰）

#### 触发时机
系统有一个**自动流转服务**，按照以下规则定时执行：

| 触发方式 | 频率 | 说明 |
|---------|------|------|
| 定时任务 | **每小时整点** | Cron: `0 * * * *` |
| 手动执行 | 按需 | 管理员手动触发 |

#### 代码位置
`backend/src/modules/customers/services/lead-auto-transfer.service.ts`

```typescript
// 第38-50行：定时任务配置
const hourlyJob = new CronJob(
  '0 * * * *', // 每小时整点执行
  () => {
    this.executeAutoTransfer().catch(err => {
      this.logger.error('定时任务执行失败:', err);
    });
  },
  null,
  true,
  'Asia/Shanghai'
);
```

**时效性**: ⏰ **最长延迟1小时** - 如果在10:01分配，下次检测是11:00

---

## ⚠️ 关键问题

### 🔴 **当前实现的局限性**

#### 问题1: 被动返回，不是主动推送

```javascript
// 当前实现（被动）
API返回 → notificationData → 前端接收 → 前端决定是否发送

// 理想实现（主动）
API执行 → 立即发送通知 → 员工收到微信消息
```

#### 问题2: 依赖前端处理

- ❌ 如果前端没有处理 `notificationData`，通知不会发送
- ❌ 如果前端处理失败，通知会丢失
- ❌ 如果用户关闭页面，通知可能不会发送

#### 问题3: 小程序端需要轮询或WebSocket

**当前方案的问题**：
- Web端分配客户后，小程序端**不会自动知道**
- 小程序端需要：
  - **方案A**: 定时轮询API检查是否有新分配
  - **方案B**: 使用WebSocket实时推送
  - **方案C**: 依赖前端在分配后主动调用通知接口

---

## ✅ 推荐的改进方案

### 方案A: 后端主动发送通知（推荐 ⭐⭐⭐⭐⭐）

#### 优势
- ✅ 实时性最好（毫秒级）
- ✅ 可靠性最高（不依赖前端）
- ✅ 用户体验最好

#### 实现方式

在分配接口中，**同步或异步**发送微信通知：

```typescript
// 修改 assignCustomerForMiniprogram 方法
async assignCustomerForMiniprogram(...) {
  // 1. 执行分配
  const updatedCustomer = await this.customersService.assignCustomer(...);

  // 2. 构建通知数据
  const notificationData = { ... };

  // 3. 🔥 立即发送微信通知（异步，不阻塞响应）
  this.sendNotificationAsync(notificationData).catch(err => {
    console.error('发送通知失败:', err);
    // 失败不影响分配操作
  });

  // 4. 返回响应（包含 notificationData 作为备份）
  return this.createResponse(true, '客户分配成功', {
    ...sanitizedCustomer,
    notificationData,
  });
}

// 异步发送通知
private async sendNotificationAsync(data: any) {
  // 查询用户的 openId
  const user = await this.userModel.findById(data.assignedToId);
  if (!user?.wechatOpenId) {
    console.log('用户未绑定微信，跳过通知');
    return;
  }

  // 调用微信订阅消息API
  await this.weixinService.sendSubscribeMessage({
    touser: user.wechatOpenId,
    template_id: 'YOUR_TEMPLATE_ID',
    page: `pages/customer/detail?id=${data.customerId}`,
    data: {
      thing1: { value: data.customerName },
      phone_number2: { value: data.customerPhone },
      thing3: { value: data.source },
      time4: { value: data.assignTime },
    }
  });
}
```

**时效性**: ⚡ **实时** - 分配后立即发送，通常在1-3秒内到达

---

### 方案B: 消息队列（推荐 ⭐⭐⭐⭐）

#### 优势
- ✅ 解耦业务逻辑
- ✅ 支持重试机制
- ✅ 不阻塞主流程

#### 实现方式

使用Redis队列或RabbitMQ：

```typescript
// 1. 分配时推送到队列
await this.queueService.addJob('customer-assignment-notification', {
  assignedToId: dto.assignedTo,
  customerName: customer.name,
  ...
});

// 2. 后台Worker处理队列
@Process('customer-assignment-notification')
async handleNotification(job: Job) {
  const data = job.data;
  await this.sendWechatNotification(data);
}
```

**时效性**: ⚡ **准实时** - 通常在1-5秒内处理

---

### 方案C: WebSocket推送（推荐 ⭐⭐⭐）

#### 优势
- ✅ 实时双向通信
- ✅ 小程序端立即收到通知

#### 实现方式

```typescript
// 后端：分配后推送WebSocket消息
this.websocketGateway.sendToUser(dto.assignedTo, {
  type: 'customer_assigned',
  data: notificationData
});

// 小程序端：监听WebSocket消息
wx.onSocketMessage((res) => {
  const msg = JSON.parse(res.data);
  if (msg.type === 'customer_assigned') {
    // 发送订阅消息
    sendSubscribeNotification(msg.data);
  }
});
```

**时效性**: ⚡ **实时** - 毫秒级推送

---

### 方案D: 当前方案（不推荐 ⭐⭐）

#### 劣势
- ❌ 依赖前端处理
- ❌ 可能丢失通知
- ❌ 小程序端无法实时感知

#### 适用场景
- 快速原型验证
- 临时解决方案

---

## 🎯 推荐实施方案

### 短期方案（1-2天）

**方案A: 后端主动发送通知**

1. 在分配接口中添加异步通知发送
2. 查询用户的 `wechatOpenId`
3. 调用微信订阅消息API
4. 失败不影响分配操作

**优势**: 
- ✅ 改动最小
- ✅ 实时性最好
- ✅ 可靠性最高

---

### 长期方案（1-2周）

**方案B: 消息队列 + WebSocket**

1. 引入Redis队列
2. 实现后台Worker
3. 添加WebSocket支持
4. 支持重试和监控

**优势**:
- ✅ 架构更优
- ✅ 可扩展性强
- ✅ 支持更多通知类型

---

## 📝 总结

### 当前状态
- ✅ 分配接口是**实时的**（毫秒级）
- ✅ 返回 `notificationData` 字段
- ❌ **不会主动发送通知**
- ❌ 依赖前端处理

### 时效性对比

| 方案 | 触发时效 | 到达时效 | 可靠性 |
|------|---------|---------|--------|
| 当前方案 | 实时 | **不确定** | ⭐⭐ |
| 后端主动发送 | 实时 | 1-3秒 | ⭐⭐⭐⭐⭐ |
| 消息队列 | 实时 | 1-5秒 | ⭐⭐⭐⭐⭐ |
| WebSocket | 实时 | <1秒 | ⭐⭐⭐⭐ |
| 定时轮询 | 延迟 | 30-60秒 | ⭐⭐⭐ |

### 建议

**立即实施**: 方案A（后端主动发送通知）

**原因**:
1. ✅ 改动最小（只需修改4个接口）
2. ✅ 实时性最好（1-3秒到达）
3. ✅ 可靠性最高（不依赖前端）
4. ✅ 用户体验最好

**需要我帮你实现方案A吗？** 👇

